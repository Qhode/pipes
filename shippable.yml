resources:
  - name: pipes_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Qhode/pipes"
      branch: master

  - name: prov_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Qhode/provision"
      branch: master

  # Terraform State for Kermit
  - name: kermit_saas_state
    type: state

  # Terraform State for ship-bits NAT
  - name: shipbits_ami_state
    type: state

  # PEM key for AWS RC account
  - name: kermit_aws_pem
    type: integration
    integration: aws-rc-pem

  # PEM key for AWS ship-bits account
  - name: shipbits_aws_pem
    type: integration
    integration: ship-bits-pem

  # CREDS for AWS RC account
  - name: kermit_aws_key
    type: integration
    integration: aws_rc_access

  # CREDS for AWS ship-bits account
  - name: shipbits_aws_key
    type: integration
    integration: aws_bits_access

  # CREDS for RT instance
  - name: rt_creds
    type: integration
    integration: rt_key

  # CREDS for github
  - name: github_creds
    type: integration
    integration: qhode_gh

  # CREDS for aws
  - name: aws_ship_bits_creds
    type: integration
    integration: aws_bits_access

  - name: kermit_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/kermit"
      branch: master

  - name: installer_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/ribbit"
      branch: master

  - name: knodeInit_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/kermit-nodeInit"
      branch: master

  - name: kreqProc_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/kermit-reqProc"
      branch: master

  - name: kreqKick_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/kermit-reqKick"
      branch: master

  - name: kexecTemplates_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/kermit-execTemplates"
      branch: master

  - name: kdb_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/postgres"
      branch: master

  - name: kvault_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/vault"
      branch: master

  - name: kmsg_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/rabbitmq"
      branch: master

  - name: kredis_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/redis"

  - name: u16node_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u16node"
      branch: master

  - name: u18node_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u18node"
      branch: master

  - name: c7node_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/c7node"
      branch: master

  - name: c7go_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/c7go"
      branch: master

  - name: c7cpp_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/c7cpp"
      branch: master

  - name: c7java_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/c7java"
      branch: master

  - name: u16go_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u16go"
      branch: master

  - name: u16cpp_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u16cpp"
      branch: master

  - name: u16java_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u16java"
      branch: master

  - name: u18go_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u18go"
      branch: master

  - name: u18cpp_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u18cpp"
      branch: master

  - name: u18java_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u18java"
      branch: master

  - name: kdb_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-postgres"
      versionName: master

  - name: kvault_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-vault"
      versionName: master

  - name: kmsg_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-msg"
      versionName: master

  - name: kredis_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-redis"
      versionName: master

  - name: kmicro_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-micro"
      versionName: master

  - name: kscriptsbase_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-scriptsbase"
      versionName: master

  - name: kapi_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-api"
      versionName: master

  - name: kwww_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-www"
      versionName: master

  - name: installer_img
    type: image
    versionTemplate:
      sourceName: "jfrog/pipelines-installer"
      versionName: master

  - name: kreqProc_img
    type: image
    integration: qhodeDH
    versionTemplate:
      sourceName: "drydock/kermit-u16reqproc"
      versionName: master

  - name: kermit_bits_cli
    type: cliConfig
    integration: aws_bits_access
    pointer:
      region: us-east-1

  - name: drydock_cli
    type: cliConfig
    integration: qhodeDH

  - name: aws_x8664_u16_img_params
    type: params
    version:
      params:
        SOURCE_AMI: "ami-66506c1c"
        VPC_ID: "vpc-266f3241"
        SUBNET_ID: "subnet-6df12f24"
        SECURITY_GROUP_ID: "sg-f634518c"
        REGION: "us-east-1"

  - name: distrobase_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/distrobase"
      branch: master

  - name: u16microbase_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "dry-dock/u16microbase"
      branch: master

  - name: distrobase_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-distrobase"
      versionName: master

  - name: u16microbase_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u16microbase"
      versionName: master

  - name: u18java_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u18java"
      versionName: master

  - name: u18go_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u18go"
      versionName: master

  - name: u18cpp_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u18cpp"
      versionName: master

  - name: u18node_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u18node"
      versionName: master

  - name: u16java_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u16java"
      versionName: master

  - name: u16go_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u16go"
      versionName: master

  - name: u16cpp_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u16cpp"
      versionName: master

  - name: u16node_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-u16node"
      versionName: master

  - name: c7java_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-c7java"
      versionName: master

  - name: c7go_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-c7go"
      versionName: master

  - name: c7cpp_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-c7cpp"
      versionName: master

  - name: c7node_x8664_img
    type: image
    versionTemplate:
      sourceName: "pipelines-docker.jfrog.io/jfrog/pipelines-c7node"
      versionName: master

  - name: reqExec_repo
    type: gitRepo
    integration: "qhode_gh"
    pointer:
      sourceName: "Shippable/kermit-reqExec"
      branch: master

jobs:
  - name: kermit_prov
    type: runSh
    steps:
      - IN: kermit_aws_pem
        switch: off
      - IN: kermit_aws_key
        switch: off
      - IN: kermit_saas_state
        switch: off
      - IN: prov_repo
        switch: off
      - TASK:
          script:
            - pushd $(shipctl get_resource_state "prov_repo")
            - ./provision.sh kermit saas rc-us-east-1
      - OUT: kermit_saas_state
    on_success:
      script:
        - echo "SUCCESS"
    on_failure:
      - script: echo 'FAILURE!'
    always:
      script:
        - ./archiveProvisionState.sh kermit saas
        - popd

  - name: shipbits_ami_prov
    type: runSh
    steps:
      - IN: shipbits_aws_pem
        switch: off
      - IN: shipbits_aws_key
        switch: off
      - IN: shipbits_ami_state
        switch: off
      - IN: prov_repo
        switch: off
      - TASK:
          script:
            - pushd $(shipctl get_resource_state "prov_repo")
            - ./provision.sh shipbits ami ship-bits
      - OUT: shipbits_ami_state
    on_success:
      script:
        - echo "SUCCESS"
    on_failure:
      - script: echo 'FAILURE!'
    always:
      script:
        - ./archiveProvisionState.sh shipbits ami
        - popd

  - name: kdb_build
    type: runSh
    steps:
      - IN: kdb_repo
      - IN: rt_creds
      - TASK:
          name: kdb_build
          runtime:
            options:
              env:
                - IMG_OUT: "kdb_img"
                - RES_REPO: "kdb_repo"
                - IMG: "postgres"
                - REL_VER: "master"
          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - docker build -t=$IMG_NAME:$REL_VER .
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kdb_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kvault_build
    type: runSh
    steps:
      - IN: kvault_repo
      - IN: rt_creds
      - TASK:
          name: kvault_build
          runtime:
            options:
              env:
                - IMG_OUT: "kvault_img"
                - RES_REPO: "kvault_repo"
                - IMG: "vault"
                - REL_VER: "master"
          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - docker build -t=$IMG_NAME:$REL_VER .
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd

      - OUT: kvault_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kmsg_build
    type: runSh
    steps:
      - IN: kmsg_repo
      - IN: rt_creds
      - TASK:
          name: kmsg_build
          runtime:
            options:
              env:
                - IMG_OUT: "kmsg_img"
                - RES_REPO: "kmsg_repo"
                - IMG: "msg"
                - REL_VER: "master"
          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - docker build -t=$IMG_NAME:$REL_VER .
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kmsg_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kredis_build
    type: runSh
    steps:
      - IN: kredis_repo
      - IN: rt_creds
      - TASK:
          name: kredis_build
          runtime:
            options:
              env:
                - IMG_OUT: "kredis_img"
                - RES_REPO: "kredis_repo"
                - IMG: "redis"
                - REL_VER: "master"
          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - docker build -t=$IMG_NAME:$REL_VER .
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd

      - OUT: kredis_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kmicro_build
    type: runSh
    steps:
      - IN: kermit_repo
      - IN: rt_creds
        switch: off
      - TASK:
          name: micro_build
          runtime:
            options:
              env:
                - IMG_OUT: "kmicro_img"
                - RES_REPO: "kermit_repo"
                - IMG: "kmicro"
                - REL_VER: "master"

          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - echo "Building $IMG_NAME:$REL_VER"
            - docker build -t=$IMG_NAME:$REL_VER .
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kmicro_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kscriptsbase_build
    type: runSh
    steps:
      - IN: kexecTemplates_repo
      - IN: kermit_repo
      - IN: rt_creds
        switch: off
      - TASK:
          name: scriptsbase_build
          runtime:
            options:
              env:
                - IMG_OUT: "kscriptsbase_img"
                - EXEC_TEMPLATES_REPO: "kexecTemplates_repo"
                - MICRO_REPO: "kermit_repo"
                - IMG: "kscriptsbase"
                - BASE_IMAGE: "drydock/u18node"
                - REL_VER: "master"
          script:
            - pushd $(shipctl get_resource_state "$EXEC_TEMPLATES_REPO")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - EXECREPO_COMMIT=$(shipctl get_resource_version_key "$EXEC_TEMPLATES_REPO" "shaData.commitSha")
            - MICROREPO_COMMIT=$(shipctl get_resource_version_key "$MICRO_REPO" "shaData.commitSha")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - export BASE_IMAGE="$BASE_IMAGE"
            - export BASE_TAG="$REL_VER"
            - export EXEC_TEMPLATES_PATH=$(realpath --relative-to="../.." $(shipctl get_resource_state "$EXEC_TEMPLATES_REPO"))
            - export MICRO_PATH=$(realpath --relative-to="../.." $(shipctl get_resource_state "$MICRO_REPO"))
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - shipctl replace Dockerfile
            - echo "Building $IMG_NAME:$REL_VER"
            - docker build -t=$IMG_NAME:$REL_VER -f Dockerfile ./../..
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kscriptsbase_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "microCommitSha=$MICROREPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "microCommitSha=$MICROREPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL


  - name: kapi_build
    type: runSh
    steps:
      - IN: kermit_repo
      - IN: knodeInit_repo
      - IN: kreqKick_repo
      - IN: kexecTemplates_repo
      - IN: rt_creds
        switch: off
      - TASK:
          name: kapi_build
          runtime:
            options:
              env:
                - NODEINIT_REPO: "knodeInit_repo"
                - REQKICK_REPO: "kreqKick_repo"
                - EXEC_TEMPLATES_REPO: "kexecTemplates_repo"
                - IMG_OUT: "kapi_img"
                - RES_REPO: "kermit_repo"
                - IMG: "kapi"
                - REL_VER: "master"

          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")/nod/api
            - echo $(shipctl get_resource_state "$NODEINIT_REPO")
            - ls -atlh $(shipctl get_resource_state "$NODEINIT_REPO")
            - tar -czf node.tar.gz -C $(shipctl get_resource_state "$NODEINIT_REPO") .
            - zip -r node.zip $(shipctl get_resource_state "$NODEINIT_REPO")
            - tar -czf reqKick.tar.gz -C $(shipctl get_resource_state "$REQKICK_REPO") .
            - zip -r reqKick.zip $(shipctl get_resource_state "$REQKICK_REPO")
            - tar -czf execTemplates.tar.gz -C $(shipctl get_resource_state "$EXEC_TEMPLATES_REPO") .
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - echo "Building $IMG_NAME:$REL_VER"
            - docker build --no-cache -t=$IMG_NAME:$REL_VER .
            - echo "Pushing $IMG_NAME;$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kapi_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kwww_build
    type: runSh
    steps:
      - IN: kermit_repo
      - IN: rt_creds
        switch: off
      - TASK:
          name: kwww_build
          runtime:
            options:
              env:
                - IMG_OUT: "kwww_img"
                - RES_REPO: "kermit_repo"
                - IMG: "kwww"
                - REL_VER: "master"

          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")/nod/www
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - echo "Building $IMG_NAME:$REL_VER"
            - docker build -t=$IMG_NAME:$REL_VER .
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kwww_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: installer_build
    type: runSh
    steps:
      - IN: installer_repo
      - IN: rt_creds
        switch: off
      - TASK:
          name: installer_build
          runtime:
            options:
              env:
                - IMG_OUT: "installer_img"
                - RES_REPO: "installer_repo"
                - IMG: "installer"
                - REL_VER: "master"

          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - IMG_NAME="$RT_REGISTRY/$IMG_NAME"
            - echo "Building $IMG_NAME:$REL_VER"
            - docker build -t=$IMG_NAME:$REL_VER -f build/docker/Dockerfile.Ubuntu .
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - echo "----------- Pushing image to installer repo ---------"
            - jfrog rt docker-push $IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - echo "----------- Gathering build info --------------------"
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
            - echo "----------- Pushing tarfile to Artifactory ----------"
            - RT_BUCKET=$(shipctl get_integration_resource_field "rt_creds" "BUCKET")
            - TAR_FILENAME="pipelines-$REL_VER.tar.gz"
            - INSTALLER_REPO_DIR=$(shipctl get_resource_state "$RES_REPO")
            - echo "----------- Removing metadata from package ----------"
            - pushd $INSTALLER_REPO_DIR
            - rm -rf .git
            - rm -rf .gitignore
            - popd
            - tar -zcf "$TAR_FILENAME" -C "$INSTALLER_REPO_DIR" .
            - jfrog rt u "$TAR_FILENAME" "$RT_BUCKET" --build-name="$JOB_NAME" --build-number="$BUILD_NUMBER"
      - OUT: installer_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: kermit_deploy
    type: runSh
    dependencyMode: strict
    runtime:
      timeoutMinutes: 15
    steps:
      - IN: installer_img
      - IN: kwww_img
      - IN: kapi_img
      - IN: kscriptsbase_img
      - IN: kmicro_img
      - IN: rt_creds
        switch: off
      - IN: pipes_repo
        switch: off
      - IN: kermit_aws_pem
        switch: off
      - IN: kermit_saas_state
        switch: off
      - TASK:
          runtime:
            options:
              env:
                - RES_PEM: "kermit_aws_pem"
                - BASTION_USER: "ec2-user"
                - ONEBOX_USER: "centos"
                - DEPLOY_VERSION: "master"
          name: deploy_to_ob
          script:
            - export BASTION_IP=$(shipctl get_resource_version_key kermit_saas_state nat_pub_ip)
            - export ONEBOX_IP=$(shipctl get_resource_version_key kermit_saas_state onebox_priv_ip)
            - export INSTALLER_IMG=$(shipctl get_resource_version_key installer_img IMG_NAME)
            - export KWWW_IMG=$(shipctl get_resource_version_key kwww_img IMG_NAME)
            - export KAPI_IMG=$(shipctl get_resource_version_key kapi_img IMG_NAME)
            - export KMICRO_IMG=$(shipctl get_resource_version_key kmicro_img IMG_NAME)
            - export KSCRIPTSBASE_IMG=$(shipctl get_resource_version_key kscriptsbase_img IMG_NAME)
            - export RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - export RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - export RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - pushd $(shipctl get_resource_state "pipes_repo")
            - ./deployKermit.sh
            - popd

  - name: kreqProc_x8664_u16_build
    type: runSh
    steps:
      - IN: kreqProc_repo
      - IN: kexecTemplates_repo
      - IN: drydock_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: kreqProc_build
          runtime:
            options:
              env:
                - IMG_OUT: "kreqProc_img"
                - RES_REPO: "kreqProc_repo"
                - IMG: "kreqProc"
                - REL_VER: "master"
                - OS: Ubuntu_16.04
                - ARCH: x86_64

          script:
            - pushd $(shipctl get_resource_state "$RES_REPO")
            #            - npm install -g jshint@v2.9.7
            #            - pushd nod
            #            - jshint .
            #            - popd
            - IMG_NAME=$(shipctl get_resource_version_key "$IMG_OUT" "sourceName")
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - sed -i "s/{{%TAG%}}/$REL_VER/g" ./image/$ARCH/$OS/Dockerfile
            - docker build --pull --no-cache -t=$IMG_NAME:$REL_VER -f image/$ARCH/$OS/Dockerfile .
            - docker push $IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-u16reqproc"
            - docker tag $IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: kreqProc_img
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

### Build AWS AMIs

  - name: base_aws_x8664_u18
    type: runSh
    dependencyMode: strict
    steps:
      - IN: aws_ship_bits_creds
        switch: off
      - IN: github_creds
        switch: off
      - IN: rt_creds
        switch: off
      - IN: shipbits_aws_pem
        switch: off
      - IN: knodeInit_repo
      - IN: pipes_repo
        switch: off
      - IN: u18java_x8664_img
      - IN: u18node_x8664_img
      - IN: u18cpp_x8664_img
      - IN: u18go_x8664_img
      - TASK:
          name: base_aws_x8664_u18
          runtime:
            options:
              env:
                - OS: "Ubuntu_18.04"
                - ARCHITECTURE: x86_64
                - SOURCE_AMI: "ami-07d0cf3af28718ef8"
                - VPC_ID: "vpc-01e8b399ee4f9f356"
                - SUBNET_ID: "subnet-06de95b9fc0434531"
                - REGION: "us-east-1"
                - SYSTEM_RUNTIME_LANGUAGE_VERSION: "master"
                - RUNTIME_VERSION: "master"
                - DOCKER_IMAGE_REGISTRY_URL: "pipelines-docker.jfrog.io"
                - GITHUB_USERNAME: "avinci"
                - PROVIDER: "aws"
                - IMG_TYPE: "base"
                - DOCKER_VERSION: "18.09"
                - SSH_USERNAME: "ubuntu"
                - SSH_BASTION_HOST: "3.227.114.92"
                - SSH_BASTION_USERNAME: "ec2-user"
                - SSH_BASTION_PRIVATE_KEY_PATH: "/tmp/ship-bits.pem"
                - PEM_KEY_RES: "shipbits_aws_pem"
          script:
            - export RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - export RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - export RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - export SOURCE_REPOSITORY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - export GITHUB_API_KEY=$(shipctl get_integration_resource_field "github_creds" "TOKEN")
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "ACCESSKEY")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "SECRETKEY")
            - pushd $(shipctl get_resource_state "pipes_repo")/machineImages/$PROVIDER/$ARCHITECTURE/$OS/$IMG_TYPE
            - cp -R ../../../templates/linux/* .
            - cp -R ../../../templates/$IMG_TYPE/* .
            - ./addPemKey.sh
            - shipctl replace vars.json
            - packer validate -var-file=vars.json packer.json
            - packer build -machine-readable -var-file=vars.json packer.json 2>&1 | tee output.txt
            - export IMAGE_NAME=$(cat output.txt | awk -F, '$0 ~/artifact,0,id/ {print $6}' | cut -d':' -f 2)
            - '[ ! -z "$IMAGE_NAME" ]'
    on_success:
      - script: shipctl put_resource_state_multi $JOB_NAME "versionName=$IMAGE_NAME" "IMAGE_NAME=$IMAGE_NAME" "SYSTEM_RUNTIME_LANGUAGE_VERSION=$SYSTEM_RUNTIME_LANGUAGE_VERSION"
      - script: shipctl put_resource_state_multi $JOB_NAME "RUNTIME_VERSION=$RUNTIME_VERSION" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS" "DOCKER_VERSION=$DOCKER_VERSION"
    on_failure:
      - script: cat $(shipctl get_resource_state pipes_repo)/aws/$ARCHITECTURE/$OS/output.txt

  - name: patch_aws_x8664_u18
    type: runSh
    dependencyMode: strict
    steps:
      - IN: aws_ship_bits_creds
        switch: off
      - IN: github_creds
        switch: off
      - IN: pipes_repo
        switch: off
      - IN: base_aws_x8664_u18
      - IN: u18repLib_x8664_build
      - IN: u18_reqExec_x8664_pack
      - IN: kreqKick_repo
      - IN: knodeInit_repo
      - IN: kexecTemplates_repo
      - TASK:
          name: patch_aws_x8664_u18
          runtime:
            options:
              env:
                - OS: "Ubuntu_18.04"
                - ARCHITECTURE: x86_64
                - VPC_ID: "vpc-266f3241"
                - SUBNET_ID: "subnet-6df12f24"
                - SECURITY_GROUP_ID: "sg-f634518c"
                - REGION: "us-east-1"
                - RUNTIME_VERSION: "master"
                - GITHUB_USERNAME: "avinci"
                - PROVIDER: "aws"
                - IMG_TYPE: "patch"
                - DOCKER_VERSION: "18.09"
                - BASE_IMG_RES: "base_aws_x8664_u18"
                - SSH_USERNAME: "ubuntu"
                # add comma separated regions where the AMI has to be copied to
                - AMI_REGIONS: "ap-south-1"
          script:
            - export SOURCE_AMI=$(shipctl get_resource_version_key "$BASE_IMG_RES" "IMAGE_NAME")
            - export GITHUB_API_KEY=$(shipctl get_integration_resource_field "github_creds" "TOKEN")
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "ACCESSKEY")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "SECRETKEY")
            - pushd $(shipctl get_resource_state "pipes_repo")/machineImages/$PROVIDER/$ARCHITECTURE/$OS/$IMG_TYPE
            - cp -R ../../../templates/linux/* .
            - cp -R ../../../templates/$IMG_TYPE/* .
            - shipctl replace vars.json
            - packer validate -var-file=vars.json packer.json
            - export AWS_POLL_DELAY_SECONDS=10
            - export AWS_MAX_ATTEMPTS=600
            - packer build -machine-readable -var-file=vars.json packer.json 2>&1 | tee output.txt
            - cat manifest.json | jq .
            - |
              export amis=$(cat manifest.json | jq -r '.builds[0].artifact_id | split(",")')
              export ami_count=$(echo $amis | jq '. | length')
              for i in $(seq 1 $ami_count); do
                ami=$(echo $amis | jq '.['"$i-1"']')
                ami_region=$(echo $ami | jq -r 'split(":") | .[0]')
                ami_id=$(echo $ami | jq -r 'split(":") | .[1]')
                if [ "$ami_region" == "$REGION" ]; then
                  export IMAGE_NAME="$ami_id"
                fi
                shipctl put_resource_state_multi $JOB_NAME "$ami_region=$ami_id"
              done
            - '[ ! -z "$IMAGE_NAME" ]'
    on_success:
      - script: shipctl put_resource_state_multi $JOB_NAME "versionName=$IMAGE_NAME" "IMAGE_NAME=$IMAGE_NAME"
      - script: shipctl put_resource_state_multi $JOB_NAME "RUNTIME_VERSION=$RUNTIME_VERSION" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS" "DOCKER_VERSION=$DOCKER_VERSION"
    on_failure:
      - script: cat $(shipctl get_resource_state pipes_repo)/aws/$ARCHITECTURE/$OS/output.txt

  - name: base_aws_x8664_u16
    type: runSh
    dependencyMode: strict
    steps:
      - IN: aws_ship_bits_creds
        switch: off
      - IN: github_creds
        switch: off
      - IN: rt_creds
        switch: off
      - IN: knodeInit_repo
      - IN: pipes_repo
        switch: off
      - IN: shipbits_aws_pem
        switch: off
      - IN: u16java_x8664_img
      - IN: u16node_x8664_img
      - IN: u16cpp_x8664_img
      - IN: u16go_x8664_img
      - TASK:
          name: base_aws_x8664_u16
          runtime:
            options:
              env:
                - OS: "Ubuntu_16.04"
                - ARCHITECTURE: x86_64
                - SOURCE_AMI: "ami-0cfee17793b08a293"
                - VPC_ID: "vpc-01e8b399ee4f9f356"
                - SUBNET_ID: "subnet-06de95b9fc0434531"
                - REGION: "us-east-1"
                - SYSTEM_RUNTIME_LANGUAGE_VERSION: "master"
                - RUNTIME_VERSION: "master"
                - DOCKER_IMAGE_REGISTRY_URL: "pipelines-docker.jfrog.io"
                - GITHUB_USERNAME: "avinci"
                - PROVIDER: "aws"
                - IMG_TYPE: "base"
                - DOCKER_VERSION: "18.09"
                - SSH_USERNAME: "ubuntu"
                - SSH_BASTION_HOST: "3.227.114.92"
                - SSH_BASTION_USERNAME: "ec2-user"
                - SSH_BASTION_PRIVATE_KEY_PATH: "/tmp/ship-bits.pem"
                - PEM_KEY_RES: "shipbits_aws_pem"
          script:
            - export RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - export RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - export RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - export SOURCE_REPOSITORY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - export GITHUB_API_KEY=$(shipctl get_integration_resource_field "github_creds" "TOKEN")
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "ACCESSKEY")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "SECRETKEY")
            - pushd $(shipctl get_resource_state "pipes_repo")/machineImages/$PROVIDER/$ARCHITECTURE/$OS/$IMG_TYPE
            - cp -R ../../../templates/linux/* .
            - cp -R ../../../templates/$IMG_TYPE/* .
            - ./addPemKey.sh
            - shipctl replace vars.json
            - packer validate -var-file=vars.json packer.json
            - packer build -machine-readable -var-file=vars.json packer.json 2>&1 | tee output.txt
            - export IMAGE_NAME=$(cat output.txt | awk -F, '$0 ~/artifact,0,id/ {print $6}' | cut -d':' -f 2)
            - '[ ! -z "$IMAGE_NAME" ]'
    on_success:
      - script: shipctl put_resource_state_multi $JOB_NAME "versionName=$IMAGE_NAME" "IMAGE_NAME=$IMAGE_NAME" "SYSTEM_RUNTIME_LANGUAGE_VERSION=$SYSTEM_RUNTIME_LANGUAGE_VERSION"
      - script: shipctl put_resource_state_multi $JOB_NAME "RUNTIME_VERSION=$RUNTIME_VERSION" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS" "DOCKER_VERSION=$DOCKER_VERSION"
    on_failure:
      - script: cat $(shipctl get_resource_state pipes_repo)/aws/$ARCHITECTURE/$OS/output.txt

  - name: patch_aws_x8664_u16
    type: runSh
    dependencyMode: strict
    steps:
      - IN: aws_ship_bits_creds
        switch: off
      - IN: github_creds
        switch: off
      - IN: pipes_repo
        switch: off
      - IN: base_aws_x8664_u16
      - IN: u16repLib_x8664_build
      - IN: u16_reqExec_x8664_pack
      - IN: kreqKick_repo
      - IN: knodeInit_repo
      - IN: kexecTemplates_repo
      - TASK:
          name: patch_aws_x8664_u16
          runtime:
            options:
              env:
                - OS: "Ubuntu_16.04"
                - ARCHITECTURE: x86_64
                - VPC_ID: "vpc-266f3241"
                - SUBNET_ID: "subnet-6df12f24"
                - SECURITY_GROUP_ID: "sg-f634518c"
                - REGION: "us-east-1"
                - RUNTIME_VERSION: "master"
                - GITHUB_USERNAME: "avinci"
                - PROVIDER: "aws"
                - IMG_TYPE: "patch"
                - DOCKER_VERSION: "18.09"
                - BASE_IMG_RES: "base_aws_x8664_u16"
                - SSH_USERNAME: "ubuntu"
                # add comma separated regions where the AMI has to be copied to
                - AMI_REGIONS: "ap-south-1"
          script:
            - export SOURCE_AMI=$(shipctl get_resource_version_key "$BASE_IMG_RES" "IMAGE_NAME")
            - export GITHUB_API_KEY=$(shipctl get_integration_resource_field "github_creds" "TOKEN")
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "ACCESSKEY")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "SECRETKEY")
            - pushd $(shipctl get_resource_state "pipes_repo")/machineImages/$PROVIDER/$ARCHITECTURE/$OS/$IMG_TYPE
            - cp -R ../../../templates/linux/* .
            - cp -R ../../../templates/$IMG_TYPE/* .
            - shipctl replace vars.json
            - packer validate -var-file=vars.json packer.json
            - export AWS_POLL_DELAY_SECONDS=10
            - export AWS_MAX_ATTEMPTS=600
            - packer build -machine-readable -var-file=vars.json packer.json 2>&1 | tee output.txt
            - cat manifest.json | jq .
            - |
              export amis=$(cat manifest.json | jq -r '.builds[0].artifact_id | split(",")')
              export ami_count=$(echo $amis | jq '. | length')
              for i in $(seq 1 $ami_count); do
                ami=$(echo $amis | jq '.['"$i-1"']')
                ami_region=$(echo $ami | jq -r 'split(":") | .[0]')
                ami_id=$(echo $ami | jq -r 'split(":") | .[1]')
                if [ "$ami_region" == "$REGION" ]; then
                  export IMAGE_NAME="$ami_id"
                fi
                shipctl put_resource_state_multi $JOB_NAME "$ami_region=$ami_id"
              done
            - '[ ! -z "$IMAGE_NAME" ]'
    on_success:
      - script: shipctl put_resource_state_multi $JOB_NAME "versionName=$IMAGE_NAME" "IMAGE_NAME=$IMAGE_NAME"
      - script: shipctl put_resource_state_multi $JOB_NAME "RUNTIME_VERSION=$RUNTIME_VERSION" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS" "DOCKER_VERSION=$DOCKER_VERSION"
    on_failure:
      - script: cat $(shipctl get_resource_state pipes_repo)/aws/$ARCHITECTURE/$OS/output.txt

  - name: base_aws_x8664_c7
    type: runSh
    dependencyMode: strict
    steps:
      - IN: aws_ship_bits_creds
        switch: off
      - IN: github_creds
        switch: off
      - IN: rt_creds
        switch: off
      - IN: knodeInit_repo
      - IN: pipes_repo
        switch: off
      - IN: shipbits_aws_pem
        switch: off
      - IN: c7java_x8664_img
      - IN: c7node_x8664_img
      - IN: c7cpp_x8664_img
      - IN: c7go_x8664_img
      - TASK:
          name: base_aws_x8664_c7
          runtime:
            options:
              env:
                - OS: "CentOS_7"
                - ARCHITECTURE: x86_64
                - SOURCE_AMI: "ami-ae7bfdb8"
                - VPC_ID: "vpc-01e8b399ee4f9f356"
                - SUBNET_ID: "subnet-06de95b9fc0434531"
                - REGION: "us-east-1"
                - SYSTEM_RUNTIME_LANGUAGE_VERSION: "master"
                - RUNTIME_VERSION: "master"
                - DOCKER_IMAGE_REGISTRY_URL: "pipelines-docker.jfrog.io"
                - GITHUB_USERNAME: "avinci"
                - PROVIDER: "aws"
                - IMG_TYPE: "base"
                - DOCKER_VERSION: "18.09"
                - SSH_USERNAME: "centos"
                - SSH_BASTION_HOST: "3.227.114.92"
                - SSH_BASTION_USERNAME: "ec2-user"
                - SSH_BASTION_PRIVATE_KEY_PATH: "/tmp/ship-bits.pem"
                - PEM_KEY_RES: "shipbits_aws_pem"
          script:
            - export RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - export RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - export RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - export SOURCE_REPOSITORY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - export GITHUB_API_KEY=$(shipctl get_integration_resource_field "github_creds" "TOKEN")
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "ACCESSKEY")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "SECRETKEY")
            - pushd $(shipctl get_resource_state "pipes_repo")/machineImages/$PROVIDER/$ARCHITECTURE/$OS/$IMG_TYPE
            - cp -R ../../../templates/linux/* .
            - cp -R ../../../templates/$IMG_TYPE/* .
            - ./addPemKey.sh
            - shipctl replace vars.json
            - packer validate -var-file=vars.json packer.json
            - packer build -machine-readable -var-file=vars.json packer.json 2>&1 | tee output.txt
            - export IMAGE_NAME=$(cat output.txt | awk -F, '$0 ~/artifact,0,id/ {print $6}' | cut -d':' -f 2)
            - '[ ! -z "$IMAGE_NAME" ]'
    on_success:
      - script: shipctl put_resource_state_multi $JOB_NAME "versionName=$IMAGE_NAME" "IMAGE_NAME=$IMAGE_NAME" "SYSTEM_RUNTIME_LANGUAGE_VERSION=$SYSTEM_RUNTIME_LANGUAGE_VERSION"
      - script: shipctl put_resource_state_multi $JOB_NAME "RUNTIME_VERSION=$RUNTIME_VERSION" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS" "DOCKER_VERSION=$DOCKER_VERSION"
    on_failure:
      - script: cat $(shipctl get_resource_state pipes_repo)/aws/$ARCHITECTURE/$OS/output.txt

  - name: patch_aws_x8664_c7
    type: runSh
    dependencyMode: strict
    steps:
      - IN: aws_ship_bits_creds
        switch: off
      - IN: github_creds
        switch: off
      - IN: pipes_repo
        switch: off
      - IN: base_aws_x8664_c7
      - IN: c7repLib_x8664_build
      - IN: c7_reqExec_x8664_pack
      - IN: kreqKick_repo
      - IN: knodeInit_repo
      - IN: kexecTemplates_repo
      - TASK:
          name: patch_aws_x8664_c7
          runtime:
            options:
              env:
                - OS: "CentOS_7"
                - ARCHITECTURE: x86_64
                - VPC_ID: "vpc-266f3241"
                - SUBNET_ID: "subnet-6df12f24"
                - SECURITY_GROUP_ID: "sg-f634518c"
                - REGION: "us-east-1"
                - RUNTIME_VERSION: "master"
                - GITHUB_USERNAME: "avinci"
                - PROVIDER: "aws"
                - IMG_TYPE: "patch"
                - DOCKER_VERSION: "18.09"
                - BASE_IMG_RES: "base_aws_x8664_c7"
                - SSH_USERNAME: "centos"
                # add comma separated regions where the AMI has to be copied to
                - AMI_REGIONS: "ap-south-1"
          script:
            - export SOURCE_AMI=$(shipctl get_resource_version_key "$BASE_IMG_RES" "IMAGE_NAME")
            - export GITHUB_API_KEY=$(shipctl get_integration_resource_field "github_creds" "TOKEN")
            - export AWS_ACCESS_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "ACCESSKEY")
            - export AWS_SECRET_KEY=$(shipctl get_integration_resource_field "aws_ship_bits_creds" "SECRETKEY")
            - pushd $(shipctl get_resource_state "pipes_repo")/machineImages/$PROVIDER/$ARCHITECTURE/$OS/$IMG_TYPE
            - cp -R ../../../templates/linux/* .
            - cp -R ../../../templates/$IMG_TYPE/* .
            - shipctl replace vars.json
            - packer validate -var-file=vars.json packer.json
            - export AWS_POLL_DELAY_SECONDS=10
            - export AWS_MAX_ATTEMPTS=600
            - packer build -machine-readable -var-file=vars.json packer.json 2>&1 | tee output.txt
            - cat manifest.json | jq .
            - |
              export amis=$(cat manifest.json | jq -r '.builds[0].artifact_id | split(",")')
              export ami_count=$(echo $amis | jq '. | length')
              for i in $(seq 1 $ami_count); do
                ami=$(echo $amis | jq '.['"$i-1"']')
                ami_region=$(echo $ami | jq -r 'split(":") | .[0]')
                ami_id=$(echo $ami | jq -r 'split(":") | .[1]')
                if [ "$ami_region" == "$REGION" ]; then
                  export IMAGE_NAME="$ami_id"
                fi
                shipctl put_resource_state_multi $JOB_NAME "$ami_region=$ami_id"
              done
            - '[ ! -z "$IMAGE_NAME" ]'
    on_success:
      - script: shipctl put_resource_state_multi $JOB_NAME "versionName=$IMAGE_NAME" "IMAGE_NAME=$IMAGE_NAME"
      - script: shipctl put_resource_state_multi $JOB_NAME "RUNTIME_VERSION=$RUNTIME_VERSION" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS" "DOCKER_VERSION=$DOCKER_VERSION"
    on_failure:
      - script: cat $(shipctl get_resource_state pipes_repo)/aws/$ARCHITECTURE/$OS/output.txt

  - name: u18repLib_x8664_build
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: kermit_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: reports_lib_build
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "Ubuntu_18.04"
                - TAG_VER: "master"
                - RES_REPO: "kermit_repo"
                - S3_URL: "s3://shippable-artifacts/pipelines-reports"
                - WEB_URL: "https://s3.amazonaws.com/shippable-artifacts/pipelines-reports"
                - REPORTS_PATH: "./gol/src/github.com/Shippable/reports"
                - RT_TARGET_REPO: pipelines-artifacts/reports
              imageName: drydock/u16golall
              imageTag: v7.2.4
          script:
            - source "/root/.gvm/scripts/gvm"
            - gvm use go1.11.5
            ## This removes the line from /etc/drydock/.env file that sources gvm command.
            - cd /etc/drydock/ && sed -i '$ d' .env
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - TAR_FILENAME="reports-$TAG_VER-$ARCHITECTURE-$OS.tar.gz"
            - REPO_DIR=$(shipctl get_resource_state "$RES_REPO")
            - export GOPATH="$REPO_DIR/gol"
            - pushd $REPO_DIR
            - pushd $REPORTS_PATH
            - ./package/$ARCHITECTURE/$OS/package.sh
            - tar -zcvf "$TAR_FILENAME" -C "$GOPATH/bin" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_URL/$TAG_VER/"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - RT_FILE_PATH=$RT_TARGET_REPO/$TAR_FILENAME
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $RT_FILE_PATH
            - popd
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "TAG_VER=$TAG_VER" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "WEB_URL=$WEB_URL" "S3_URL=$S3_URL" "TAR_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS"
        - shipctl put_resource_state_multi $JOB_NAME "RT_TARGET_REPO=$RT_TARGET_REPO" "RT_FILE_PATH=$RT_FILE_PATH"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: u16repLib_x8664_build
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: kermit_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: reports_lib_build
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "Ubuntu_16.04"
                - TAG_VER: "master"
                - RES_REPO: "kermit_repo"
                - S3_URL: "s3://shippable-artifacts/pipelines-reports"
                - WEB_URL: "https://s3.amazonaws.com/shippable-artifacts/pipelines-reports"
                - REPORTS_PATH: "./gol/src/github.com/Shippable/reports"
                - RT_TARGET_REPO: pipelines-artifacts/reports
              imageName: drydock/u16golall
              imageTag: v7.2.4
          script:
            - source "/root/.gvm/scripts/gvm"
            - gvm use go1.11.5
            ## This removes the line from /etc/drydock/.env file that sources gvm command.
            - cd /etc/drydock/ && sed -i '$ d' .env
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - TAR_FILENAME="reports-$TAG_VER-$ARCHITECTURE-$OS.tar.gz"
            - REPO_DIR=$(shipctl get_resource_state "$RES_REPO")
            - export GOPATH="$REPO_DIR/gol"
            - pushd $REPO_DIR
            - pushd $REPORTS_PATH
            - ./package/$ARCHITECTURE/$OS/package.sh
            - tar -zcvf "$TAR_FILENAME" -C "$GOPATH/bin" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_URL/$TAG_VER/"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - RT_FILE_PATH=$RT_TARGET_REPO/$TAR_FILENAME
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $RT_FILE_PATH
            - popd
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "TAG_VER=$TAG_VER" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "WEB_URL=$WEB_URL" "S3_URL=$S3_URL" "TAR_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS"
        - shipctl put_resource_state_multi $JOB_NAME "RT_TARGET_REPO=$RT_TARGET_REPO" "RT_FILE_PATH=$RT_FILE_PATH"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: c7repLib_x8664_build
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: kermit_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: reports_lib_build
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "CentOS_7"
                - TAG_VER: "master"
                - RES_REPO: "kermit_repo"
                - S3_URL: "s3://shippable-artifacts/pipelines-reports"
                - WEB_URL: "https://s3.amazonaws.com/shippable-artifacts/pipelines-reports"
                - REPORTS_PATH: "./gol/src/github.com/Shippable/reports"
                - RT_TARGET_REPO: pipelines-artifacts/reports
              imageName: drydock/u16golall
              imageTag: v7.2.4
          script:
            - source "/root/.gvm/scripts/gvm"
            - gvm use go1.11.5
            ## This removes the line from /etc/drydock/.env file that sources gvm command.
            - cd /etc/drydock/ && sed -i '$ d' .env
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - TAR_FILENAME="reports-$TAG_VER-$ARCHITECTURE-$OS.tar.gz"
            - REPO_DIR=$(shipctl get_resource_state "$RES_REPO")
            - export GOPATH="$REPO_DIR/gol"
            - pushd $REPO_DIR
            - pushd $REPORTS_PATH
            - ./package/$ARCHITECTURE/$OS/package.sh
            - tar -zcvf "$TAR_FILENAME" -C "$GOPATH/bin" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_URL/$TAG_VER/"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - RT_FILE_PATH=$RT_TARGET_REPO/$TAR_FILENAME
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $RT_FILE_PATH
            - popd
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "TAG_VER=$TAG_VER" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "WEB_URL=$WEB_URL" "S3_URL=$S3_URL" "TAR_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS"
        - shipctl put_resource_state_multi $JOB_NAME "RT_TARGET_REPO=$RT_TARGET_REPO" "RT_FILE_PATH=$RT_FILE_PATH"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: rhel7repLib_x8664_build
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: kermit_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: reports_lib_build
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "RHEL_7"
                - TAG_VER: "master"
                - RES_REPO: "kermit_repo"
                - S3_URL: "s3://shippable-artifacts/pipelines-reports"
                - WEB_URL: "https://s3.amazonaws.com/shippable-artifacts/pipelines-reports"
                - REPORTS_PATH: "./gol/src/github.com/Shippable/reports"
                - RT_TARGET_REPO: pipelines-artifacts/reports
              imageName: drydock/u16golall
              imageTag: v7.2.4
          script:
            - source "/root/.gvm/scripts/gvm"
            - gvm use go1.11.5
            ## This removes the line from /etc/drydock/.env file that sources gvm command.
            - cd /etc/drydock/ && sed -i '$ d' .env
            - REPO_COMMIT=$(shipctl get_resource_version_key "$RES_REPO" "shaData.commitSha")
            - TAR_FILENAME="reports-$TAG_VER-$ARCHITECTURE-$OS.tar.gz"
            - REPO_DIR=$(shipctl get_resource_state "$RES_REPO")
            - export GOPATH="$REPO_DIR/gol"
            - pushd $REPO_DIR
            - pushd $REPORTS_PATH
            - ./package/$ARCHITECTURE/$OS/package.sh
            - tar -zcvf "$TAR_FILENAME" -C "$GOPATH/bin" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_URL/$TAG_VER/"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - RT_FILE_PATH=$RT_TARGET_REPO/$TAR_FILENAME
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $RT_FILE_PATH
            - popd
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "TAG_VER=$TAG_VER" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "WEB_URL=$WEB_URL" "S3_URL=$S3_URL" "TAR_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$ARCHITECTURE" "OS=$OS"
        - shipctl put_resource_state_multi $JOB_NAME "RT_TARGET_REPO=$RT_TARGET_REPO" "RT_FILE_PATH=$RT_FILE_PATH"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: u18cpp_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u18cpp_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u18cpp_x8664_img
      - TASK:
          name: u18cpp_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u18cpp"
                - REL_VER: "master"
                - IMG_OUT: "u18cpp_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u18cpp_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u18cpp_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u18go_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u18go_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u18go_x8664_img
      - TASK:
          name: u18go_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u18go"
                - REL_VER: "master"
                - IMG_OUT: "u18go_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u18go_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u18go_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u18java_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u18java_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u18java_x8664_img
      - TASK:
          name: u18java_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u18java"
                - REL_VER: "master"
                - IMG_OUT: "u18java_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u18java_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u18java_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u18node_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u18node_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u18node_x8664_img
      - TASK:
          name: u18node_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u18node"
                - REL_VER: "master"
                - IMG_OUT: "u18node_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u18node_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u18node_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: c7node_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: c7node_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: c7node_x8664_img
      - TASK:
          name: c7node_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "c7node"
                - REL_VER: "master"
                - IMG_OUT: "c7node_x8664_img"
          script:
            - pushd $(shipctl get_resource_state c7node_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "c7node_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: c7go_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: c7go_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: c7go_x8664_img
      - TASK:
          name: c7go_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "c7go"
                - REL_VER: "master"
                - IMG_OUT: "c7go_x8664_img"
          script:
            - pushd $(shipctl get_resource_state c7go_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "c7go_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: c7cpp_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: c7cpp_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: c7cpp_x8664_img
      - TASK:
          name: c7cpp_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "c7cpp"
                - REL_VER: "master"
                - IMG_OUT: "c7cpp_x8664_img"
          script:
            - pushd $(shipctl get_resource_state c7cpp_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "c7cpp_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: c7java_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: c7java_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: c7java_x8664_img
      - TASK:
          name: c7java_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "c7java"
                - REL_VER: "master"
                - IMG_OUT: "c7java_x8664_img"
          script:
            - pushd $(shipctl get_resource_state c7java_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "c7java_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u16node_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u16node_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u16node_x8664_img
      - TASK:
          name: u16node_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u16node"
                - REL_VER: "master"
                - IMG_OUT: "u16node_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u16node_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u16node_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u16go_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u16go_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u16go_x8664_img
      - TASK:
          name: u16go_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u16go"
                - REL_VER: "master"
                - IMG_OUT: "u16go_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u16go_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u16node_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u16cpp_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u16cpp_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u16cpp_x8664_img
      - TASK:
          name: u16cpp_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u16cpp"
                - REL_VER: "master"
                - IMG_OUT: "u16cpp_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u16cpp_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u16cpp_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: u16java_x8664_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u16java_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - OUT: u16java_x8664_img
      - TASK:
          name: u16java_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u16java"
                - REL_VER: "master"
                - IMG_OUT: "u16java_x8664_img"
          script:
            - pushd $(shipctl get_resource_state u16java_repo)
            - REPO_COMMIT=$(shipctl get_resource_version_key "u16java_repo" "shaData.commitSha")
            - docker build -t=$IMG_REPO_NAME/$IMG_NAME:$REL_VER .
            - docker push $IMG_REPO_NAME/$IMG_NAME:$REL_VER
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker tag $IMG_REPO_NAME/$IMG_NAME:$REL_VER $RT_IMG_NAME:$REL_VER
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"
        - shipctl put_resource_state_multi $IMG_OUT "versionName=$REL_VER" "IMG_REPO_COMMIT_SHA=$REPO_COMMIT"

  - name: distrobase_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: distrobase_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - TASK:
          name: distrobase_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "distrobase"
                - REL_VER: "master"
                - IMG_JFROG_OUT: "distrobase_img"
          script:
            - pushd $(shipctl get_resource_state distrobase_repo)
            - export IMG_NAME="$IMG_REPO_NAME/$IMG_NAME"
            - ./build.sh
            - docker push "${IMG_NAME}:${REL_VER}"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-distrobase"
            - docker tag "${IMG_NAME}:${REL_VER}" $RT_IMG_NAME:$REL_VER
            - echo "Pushing $IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: distrobase_img
    on_success:
      script:
        - shipctl put_resource_state_multi $IMG_JFROG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: u16microbase_build
    type: runSh
    dependencyMode: strict
    steps:
      - IN: u16microbase_repo
      - IN: drydock_cli
      - IN: rt_creds
        switch: off
      - TASK:
          name: u16microbase_build
          runtime:
            options:
              env:
                - IMG_REPO_NAME: "drydock"
                - IMG_NAME: "u16microbase"
                - REL_VER: "master"
                - IMG_JFROG_OUT: "u16microbase_img"
          script:
            - pushd $(shipctl get_resource_state u16microbase_repo)
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - RT_REGISTRY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY")
            - RT_REGISTRY_KEY=$(shipctl get_integration_resource_field "rt_creds" "REGISTRY_KEY")
            - RT_IMG_NAME="$RT_REGISTRY/jfrog/pipelines-$IMG_NAME"
            - docker build -t=$RT_REGISTRY/jfrog/pipelines-$IMG_NAME:$REL_VER .
            - echo "Pushing $RT_REGISTRY/jfrog/pipelines-$IMG_NAME:$REL_VER to Artifactory"
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - jfrog rt docker-push $RT_IMG_NAME:$REL_VER $RT_REGISTRY_KEY --build-name=$JOB_NAME --build-number=$BUILD_NUMBER
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
      - OUT: u16microbase_img
    on_success:
      script:
        - shipctl put_resource_state_multi $IMG_JFROG_OUT "versionName=$REL_VER" "commitSha=$REPO_COMMIT" "IMG_NAME=$IMG_NAME" "IMG_TAG=$REL_VER"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: u18_reqExec_x8664_pack
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: reqExec_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: u18_reqexec_pack
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "Ubuntu_18.04"
                - ARTIFACTS_BUCKET: "s3://shippable-artifacts/pipelines-reqExec"
                - REL_VER: "master"
                - BINARY_DIR: "/tmp/reqExec"
          script:
            - pushd $(shipctl get_resource_state "reqExec_repo")
            - REPO_COMMIT=$(shipctl get_resource_version_key "reqExec_repo" "shaData.commitSha")
            - TAR_FILENAME="reqExec-$REL_VER-$ARCHITECTURE-$OS.tar.gz"
            - PACK_SCRIPT="./package/$ARCHITECTURE/$OS/package.sh"
            - S3_BUCKET_BINARY_DIR="$ARTIFACTS_BUCKET/$REL_VER/"
            - $PACK_SCRIPT
            - mkdir -p $BINARY_DIR && cp -r dist $BINARY_DIR
            - tar -zcvf "$TAR_FILENAME" -C "$BINARY_DIR" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_BUCKET_BINARY_DIR"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - TARGET_LOCATION=pipelines-artifacts/reqExec
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $TARGET_LOCATION/$TAR_FILENAME
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "S3_BUCKET=$S3_BUCKET_BINARY_DIR" "S3_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$RCHITECTURE" "OS=$OS"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: u16_reqExec_x8664_pack
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: reqExec_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: u16_reqexec_pack
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "Ubuntu_16.04"
                - ARTIFACTS_BUCKET: "s3://shippable-artifacts/pipelines-reqExec"
                - REL_VER: "master"
                - BINARY_DIR: "/tmp/reqExec"
          script:
            - pushd $(shipctl get_resource_state "reqExec_repo")
            - REPO_COMMIT=$(shipctl get_resource_version_key "reqExec_repo" "shaData.commitSha")
            - TAR_FILENAME="reqExec-$REL_VER-$ARCHITECTURE-$OS.tar.gz"
            - PACK_SCRIPT="./package/$ARCHITECTURE/$OS/package.sh"
            - S3_BUCKET_BINARY_DIR="$ARTIFACTS_BUCKET/$REL_VER/"
            - $PACK_SCRIPT
            - mkdir -p $BINARY_DIR && cp -r dist $BINARY_DIR
            - tar -zcvf "$TAR_FILENAME" -C "$BINARY_DIR" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_BUCKET_BINARY_DIR"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - TARGET_LOCATION=pipelines-artifacts/reqExec
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $TARGET_LOCATION/$TAR_FILENAME
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "S3_BUCKET=$S3_BUCKET_BINARY_DIR" "S3_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$RCHITECTURE" "OS=$OS"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: c7_reqExec_x8664_pack
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: reqExec_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: c7_reqexec_pack
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "CentOS_7"
                - ARTIFACTS_BUCKET: "s3://shippable-artifacts/pipelines-reqExec"
                - REL_VER: "master"
                - BINARY_DIR: "/tmp/reqExec"
          script:
            - pushd $(shipctl get_resource_state "reqExec_repo")
            - REPO_COMMIT=$(shipctl get_resource_version_key "reqExec_repo" "shaData.commitSha")
            - TAR_FILENAME="reqExec-$REL_VER-$ARCHITECTURE-$OS.tar.gz"
            - PACK_SCRIPT="./package/$ARCHITECTURE/$OS/package.sh"
            - S3_BUCKET_BINARY_DIR="$ARTIFACTS_BUCKET/$REL_VER/"
            - $PACK_SCRIPT
            - mkdir -p $BINARY_DIR && cp -r dist $BINARY_DIR
            - tar -zcvf "$TAR_FILENAME" -C "$BINARY_DIR" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_BUCKET_BINARY_DIR"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - TARGET_LOCATION=pipelines-artifacts/reqExec
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $TARGET_LOCATION/$TAR_FILENAME
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "S3_BUCKET=$S3_BUCKET_BINARY_DIR" "S3_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$RCHITECTURE" "OS=$OS"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL

  - name: rhel7_reqExec_x8664_pack
    type: runSh
    triggerMode: parallel
    dependencyMode: strict
    steps:
      - IN: reqExec_repo
      - IN: kermit_bits_cli
        switch: off
      - IN: rt_creds
        switch: off
      - TASK:
          name: rhel7_reqexec_pack
          runtime:
            options:
              env:
                - ARCHITECTURE: "x86_64"
                - OS: "RHEL_7"
                - ARTIFACTS_BUCKET: "s3://shippable-artifacts/pipelines-reqExec"
                - REL_VER: "master"
                - BINARY_DIR: "/tmp/reqExec"
          script:
            - pushd $(shipctl get_resource_state "reqExec_repo")
            - REPO_COMMIT=$(shipctl get_resource_version_key "reqExec_repo" "shaData.commitSha")
            - TAR_FILENAME="reqExec-$REL_VER-$ARCHITECTURE-$OS.tar.gz"
            - PACK_SCRIPT="./package/$ARCHITECTURE/$OS/package.sh"
            - S3_BUCKET_BINARY_DIR="$ARTIFACTS_BUCKET/$REL_VER/"
            - $PACK_SCRIPT
            - mkdir -p $BINARY_DIR && cp -r dist $BINARY_DIR
            - tar -zcvf "$TAR_FILENAME" -C "$BINARY_DIR" .
            - aws s3 cp --acl public-read "$TAR_FILENAME" "$S3_BUCKET_BINARY_DIR"
            - RT_URL=$(shipctl get_integration_resource_field "rt_creds" "RT_URL")
            - RT_API_KEY=$(shipctl get_integration_resource_field "rt_creds" "API_KEY")
            - RT_USER=$(shipctl get_integration_resource_field "rt_creds" "USER")
            - jfrog rt config --url "$RT_URL" --user "$RT_USER" --apikey "$RT_API_KEY" --interactive=false
            - TARGET_LOCATION=pipelines-artifacts/reqExec
            - jfrog rt upload --build-name=$JOB_NAME --build-number=$BUILD_NUMBER $TAR_FILENAME $TARGET_LOCATION/$TAR_FILENAME
            - jfrog rt bag $JOB_NAME $BUILD_NUMBER
            - popd
    on_success:
      script:
        - shipctl put_resource_state_multi $JOB_NAME "versionName=$REPO_COMMIT" "FILE_REPO_COMMIT_SHA=$REPO_COMMIT" "S3_BUCKET=$S3_BUCKET_BINARY_DIR" "S3_FILENAME=$TAR_FILENAME" "ARCHITECTURE=$RCHITECTURE" "OS=$OS"
        - echo "Publishing build info"
        - jfrog rt bp $JOB_NAME $BUILD_NUMBER --build-url $BUILD_URL
